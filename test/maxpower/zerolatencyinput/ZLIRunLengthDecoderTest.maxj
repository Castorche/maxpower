package maxpower.zerolatencyinput;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Random;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.Reductions;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Params;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFETypeFactory;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStruct;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStructType;
import com.maxeler.maxcompiler.v2.managers.standard._DualSimulationManager;
import com.maxeler.maxcompiler.v2.managers.standard._DualSimulationManager.DualSimMode;
import com.maxeler.maxcompiler.v2.utils.Bits;

// TODO JUnit
public class ZLIRunLengthDecoderTest {
	private static final int N = 1000; // number of data items

	private static final DFEType intType = DFETypeFactory.dfeInt(32);
	private static final DFEStructType rleType =
		new DFEStructType(
				DFEStructType.sft("repeats", intType),
				DFEStructType.sft("data", intType)
			);

	static class ZLIRunLengthDecoderTestKernel extends Kernel {

		protected ZLIRunLengthDecoderTestKernel(KernelParameters parameters) {
			super(parameters);

			/*
			 * We need to streamHold the enable signal (then negative offset) as the scheduler
			 * will not allow us to create a loop with no latency anywhere.
			 */
			DFEVar  enable = dfeBool().newInstance(this);
			DFEVar _enable = stream.offset(enable, -1); // first cycle value (true) comes from streamHold reset below

			DFEStruct rleInput = ZeroLatencyInput.input("rle_in", rleType, _enable);

			Params params = control.count.makeParams(32).withMax((DFEVar) rleInput.get("repeats"));
			Counter count = control.count.makeCounter(params);

			enable <== Reductions.streamHold(count.getWrap(), constant.var(true), dfeBool().encodeConstant(true));

			io.output("rle_out", intType) <== (DFEVar) rleInput.get("data");
		}
	}

	public static void main(String[] args) {
		_DualSimulationManager m = new _DualSimulationManager("ZLIRunLengthDecoderTest", DualSimMode.PARALLEL);
		m.setKernels(new ZLIRunLengthDecoderTestKernel(m.makeKernelParameters_A()),
			new ZLIRunLengthDecoderTestKernel(m.makeKernelParameters_B()));

		Random rng = new Random();

		List<Double> expOutput = new ArrayList<Double>(5*N);

		int cycles = 0;
		Bits[] rleInput = new Bits[N];
		for (int i = 0; i < N; ++i) {
			HashMap<String, Double> fields = new HashMap<String, Double>();
			int repeats = rng.nextInt(10)+1; // 0 repeats is bad, m'kay
			int data    = rng.nextInt(100)+1;
			fields.put("repeats", (double) repeats);
			fields.put("data",    (double) data);
			rleInput[i] = rleType.encodeConstant(fields);

			for (int n = 0; n < repeats; ++n)
				expOutput.add((double) data);
			cycles += repeats;
		}

		m.setInputDataRaw("rle_in", rleInput);

		m.setScalarInput("rle_in_ZLI_inputLength", N);

		m.setKernelCycles(cycles);
		m.runTest();

		double[] expOutputArray = new double[expOutput.size()];
		for (int i = 0; i < expOutput.size(); ++i)
			expOutputArray[i] = expOutput[i];

		m.checkOutputData("rle_out", expOutputArray);
		m.logMsg("Test PASSED");
	}
}
